#!/usr/bin/env escript
%% -*- erlang -*-
%%! -smp enable
-record(state, {clients, messages}).

-mode(compile).

stats() ->
    [
     {clients, folsom_metrics:get_metric_value(clients)},
     {handshakes, folsom_metrics:get_metric_value(handshakes)},
     {connection_timeouts, folsom_metrics:get_metric_value(connection_timeouts)},
     {handshake_time, folsom_metrics:get_histogram_statistics(handshake_time)},
     {message_latency,
        folsom_metrics:get_histogram_statistics(message_latency)},
     {messages_sent, folsom_metrics:get_metric_value(messages_sent)},
     {messages_recv, folsom_metrics:get_metric_value(messages_recv)},
     {crashes, folsom_metrics:get_metric_value(crashes)}
    ].

% returns and erases a value if it is in the dict,
% or stores if it does not exist
pop_or_set(Key, OtherValue, D) ->
    case dict:find(Key, D) of
        {ok, Value} -> {pop, Value, dict:erase(Key, D)};
        error -> {set, dict:store(Key, OtherValue, D)}
    end.

% If a time is already found in the dict, update the 
% elapsed time for Metric
update_elapsed_time(Metric, Key, Start, undefined, D) ->
    case pop_or_set(Key, Start, D) of
        {pop, End, D2} ->
            update_elapsed_time(Metric, Key, Start, End, D2);
        {set, D2} -> D2
    end;
update_elapsed_time(Metric, Key, undefined, End, D) ->
    case pop_or_set(Key, End, D) of
        {pop, Start, D2} ->
            update_elapsed_time(Metric, Key, Start, End, D2);
        {set, D2} -> D2
    end;
update_elapsed_time(Metric, _, Start, End, D) ->    
    Elapsed = timer:now_diff(End, Start) / 1000,
    folsom_metrics:notify({Metric, Elapsed}),
    D.
    

reducer({Start, {ws_init, Pid}}, #state{clients=C} = State) ->
    folsom_metrics:notify({clients, {inc, 1}}),
    C2 = update_elapsed_time(handshake_time, Pid, Start, undefined, C),
    State#state{clients=C2};
reducer({End, {ws_onopen, Pid}}, #state{clients=C} = State) ->
    folsom_metrics:notify({handshakes, {inc, 1}}),
    C2 = update_elapsed_time(handshake_time, Pid, undefined, End, C),
    State#state{clients=C2};
reducer({Start, {send_message, Pid, Ref}}, #state{messages=M} = State) ->
    folsom_metrics:notify({messages_sent, {inc, 1}}),
    M2 = update_elapsed_time(message_latency, {Pid, Ref}, Start, undefined, M),
    State#state{messages=M2};
reducer({End, {recv_message, Pid, Ref}}, #state{messages=M} = State) ->
    folsom_metrics:notify({messages_recv, {inc, 1}}),
    M2 = update_elapsed_time(message_latency, {Pid, Ref}, undefined, End, M),
    State#state{messages=M2};
% ignore normal exits
reducer({_TS, {'EXIT', _Pid, normal}}, State) ->
    State;
% record connection timeouts seperately
reducer({_TS, {'EXIT', _Pid, connection_timeout}}, State) ->
    folsom_metrics:notify({connection_timeouts, {inc, 1}}),
    State;
% record connection other crashes
reducer({_TS, {'EXIT', _Pid, _Reason}}, State) ->
    folsom_metrics:notify({crashes, {inc, 1}}),
    State;
reducer(E, State) ->
    io:format("~p~n", [E]),
    State.

main([LogFile]) ->
    code:add_paths(["ebin",
                    "deps/eleveldb/ebin",
                    "deps/bear/ebin",
                    "deps/folsom/ebin"]),

    application:start(folsom),

    folsom_metrics:new_histogram(handshake_time),
    folsom_metrics:new_counter(clients),
    folsom_metrics:new_counter(handshakes),

    folsom_metrics:new_histogram(message_latency),
    folsom_metrics:new_counter(messages_sent),
    folsom_metrics:new_counter(messages_recv),
    folsom_metrics:new_counter(crashes),
    folsom_metrics:new_counter(connection_timeouts),

    wsdemo_logger:foldl(fun reducer/2,
                        #state{clients=dict:new(),
                               messages=dict:new()},
                       LogFile),
    
    io:format("~p~n", [stats()]);
main(_) ->
    usage().

                
usage() ->
    io:format("usage: ~n"
     "cat_stats LogFile::string()",[]).

    
